<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures & Algorithms Study Guide with Python Examples</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            font-size: 2.5rem;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .section {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .section-title {
            color: #764ba2;
            font-size: 1.8rem;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .data-structure {
            margin-bottom: 30px;
            border-left: 4px solid #667eea;
            padding-left: 20px;
        }

        .ds-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .ds-title {
            font-size: 1.3rem;
            color: #495057;
            font-weight: bold;
            margin-right: 15px;
        }

        .complexity {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .complexity.good {
            background: #d4edda;
            color: #155724;
        }

        .complexity.average {
            background: #fff3cd;
            color: #856404;
        }

        .complexity.poor {
            background: #f8d7da;
            color: #721c24;
        }

        .ds-description {
            color: #6c757d;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .code-container {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            overflow-x: auto;
            margin-top: 10px;
        }

        pre {
            margin: 0;
            color: #d4d4d4;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            white-space: pre;
        }

        /* Syntax highlighting */
        .keyword {
            color: #569cd6;
        }

        .string {
            color: #ce9178;
        }

        .comment {
            color: #6a9955;
        }

        .function {
            color: #dcdcaa;
        }

        .number {
            color: #b5cea8;
        }

        .tab-container {
            margin-top: 10px;
        }

        .tab-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 0;
            flex-wrap: wrap;
        }

        .tab-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s;
        }

        .tab-button:hover {
            background: #764ba2;
        }

        .tab-button.active {
            background: #1e1e1e;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tradeoffs-section {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .tradeoffs-section h2 {
            color: #764ba2;
            margin-bottom: 20px;
            font-size: 1.8rem;
            text-align: center;
        }

        .tradeoff-item {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            border: 1px solid #667eea30;
        }

        .tradeoff-item h3 {
            color: #495057;
            margin-bottom: 10px;
        }

        ul {
            list-style: none;
            padding-left: 0;
        }

        ul li {
            padding: 8px 0;
            padding-left: 25px;
            position: relative;
        }

        ul li:before {
            content: "‚ñ∏";
            position: absolute;
            left: 0;
            color: #667eea;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .section-title {
                font-size: 1.4rem;
            }

            .ds-title {
                font-size: 1.1rem;
            }

            pre {
                font-size: 0.75rem;
            }
        }

        nav {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            margin-bottom: 30px;
            position: sticky;
            top: 20px;
            z-index: 1000;
        }

        nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }

        nav li {
            position: relative;
        }

        nav a {
            text-decoration: none;
            color: #333;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: 5px;
            transition: all 0.3s ease;
            display: block;
        }

        nav a:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
        }
    </style>
</head>

<body>
    <nav>
        <ul>
            <li class="logo">üìö Study Hub</li>
            <li><a href="index.html">Home</a></li>
            <li><a href="interview_crash_course.html">Interview Prep</a></li>
            <li><a href="csharp_basics.html">C# Basics</a></li>
            <li><a href="javascript_basics.html">JavaScript Basics</a></li>
            <li><a href="java_basics.html">Java Basics</a></li>
            <li><a href="Study_Guide.html">Study Guide 1</a></li>
            <li><a href="Study_guide_2.html">Study Guide 2</a></li>
            <li><a href="GUI_interview_crash_course.html">GUI Interview</a></li>
        </ul>
    </nav>
    <div class="container">
        <h1>üìö Data Structures & Algorithms Study Guide with Python üêç</h1>

        <!-- Hash-based Structures Section -->
        <div class="section">
            <h2 class="section-title">Hash-Based Structures</h2>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Hash Map / Dictionary</span>
                    <span class="complexity good">O(1) average</span>
                </div>
                <p class="ds-description">
                    Key-value pairs with fast lookup, insertion, and deletion. Python's dict is a highly optimized hash
                    map implementation.
                </p>
                <div class="code-container">
                    <pre><code><span class="comment"># Python Dictionary (Hash Map) - Basic Operations</span>
<span class="comment"># Creation and initialization</span>
hash_map = {}  <span class="comment"># Empty dictionary</span>
hash_map = {<span class="string">"apple"</span>: <span class="number">5</span>, <span class="string">"banana"</span>: <span class="number">3</span>}  <span class="comment"># With initial values</span>
hash_map = dict(apple=<span class="number">5</span>, banana=<span class="number">3</span>)  <span class="comment"># Alternative syntax</span>

<span class="comment"># Insert/Update - O(1) average</span>
hash_map[<span class="string">"orange"</span>] = <span class="number">7</span>
hash_map.update({<span class="string">"grape"</span>: <span class="number">4</span>, <span class="string">"peach"</span>: <span class="number">6</span>})

<span class="comment"># Access - O(1) average</span>
value = hash_map[<span class="string">"apple"</span>]  <span class="comment"># Returns 5, raises KeyError if not found</span>
value = hash_map.get(<span class="string">"kiwi"</span>, <span class="number">0</span>)  <span class="comment"># Returns 0 if not found (safe access)</span>

<span class="comment"># Delete - O(1) average</span>
<span class="keyword">del</span> hash_map[<span class="string">"apple"</span>]  <span class="comment"># Raises KeyError if not found</span>
value = hash_map.pop(<span class="string">"banana"</span>, <span class="keyword">None</span>)  <span class="comment"># Returns value or None if not found</span>

<span class="comment"># Check existence - O(1) average</span>
<span class="keyword">if</span> <span class="string">"orange"</span> <span class="keyword">in</span> hash_map:
    <span class="keyword">print</span>(<span class="string">f"Orange count: {hash_map['orange']}"</span>)

<span class="comment"># Iteration patterns</span>
<span class="keyword">for</span> key <span class="keyword">in</span> hash_map:  <span class="comment"># Iterate over keys</span>
    <span class="keyword">print</span>(key)

<span class="keyword">for</span> key, value <span class="keyword">in</span> hash_map.items():  <span class="comment"># Iterate over key-value pairs</span>
    <span class="keyword">print</span>(<span class="string">f"{key}: {value}"</span>)

<span class="keyword">for</span> value <span class="keyword">in</span> hash_map.values():  <span class="comment"># Iterate over values only</span>
    <span class="keyword">print</span>(value)</code></pre>
                </div>
            </div>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Custom Hash Table Implementation</span>
                    <span class="complexity good">O(1) average</span>
                </div>
                <p class="ds-description">
                    Custom hash table with collision handling through chaining. Useful for understanding internals.
                </p>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">HashTable</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, size=<span class="number">10</span>):
        self.size = size
        self.table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)]  <span class="comment"># List of buckets</span>
        self.count = <span class="number">0</span>
    
    <span class="keyword">def</span> <span class="function">_hash</span>(self, key):
        <span class="comment"># Simple hash function using Python's built-in hash</span>
        <span class="keyword">return</span> hash(key) % self.size
    
    <span class="keyword">def</span> <span class="function">insert</span>(self, key, value):
        index = self._hash(key)
        bucket = self.table[index]
        
        <span class="comment"># Check if key exists and update</span>
        <span class="keyword">for</span> i, (k, v) <span class="keyword">in</span> enumerate(bucket):
            <span class="keyword">if</span> k == key:
                bucket[i] = (key, value)
                <span class="keyword">return</span>
        
        <span class="comment"># Add new key-value pair</span>
        bucket.append((key, value))
        self.count += <span class="number">1</span>
        
        <span class="comment"># Check load factor and resize if needed</span>
        <span class="keyword">if</span> self.count > self.size * <span class="number">0.75</span>:
            self._resize()
    
    <span class="keyword">def</span> <span class="function">get</span>(self, key):
        index = self._hash(key)
        bucket = self.table[index]
        
        <span class="keyword">for</span> k, v <span class="keyword">in</span> bucket:
            <span class="keyword">if</span> k == key:
                <span class="keyword">return</span> v
        <span class="keyword">raise</span> KeyError(key)
    
    <span class="keyword">def</span> <span class="function">delete</span>(self, key):
        index = self._hash(key)
        bucket = self.table[index]
        
        <span class="keyword">for</span> i, (k, v) <span class="keyword">in</span> enumerate(bucket):
            <span class="keyword">if</span> k == key:
                <span class="keyword">del</span> bucket[i]
                self.count -= <span class="number">1</span>
                <span class="keyword">return</span>
        <span class="keyword">raise</span> KeyError(key)
    
    <span class="keyword">def</span> <span class="function">_resize</span>(self):
        <span class="comment"># Double the size and rehash all elements</span>
        old_table = self.table
        self.size *= <span class="number">2</span>
        self.table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.size)]
        self.count = <span class="number">0</span>
        
        <span class="keyword">for</span> bucket <span class="keyword">in</span> old_table:
            <span class="keyword">for</span> key, value <span class="keyword">in</span> bucket:
                self.insert(key, value)</code></pre>
                </div>
            </div>
        </div>

        <!-- Tree Structures Section -->
        <div class="section">
            <h2 class="section-title">Tree Structures</h2>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Binary Search Tree (BST)</span>
                    <span class="complexity average">O(log n) balanced, O(n) worst</span>
                </div>
                <p class="ds-description">
                    Hierarchical structure where left children are smaller and right children are larger than parent.
                    Enables efficient searching and sorted traversal.
                </p>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">TreeNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, val):
        self.val = val
        self.left = <span class="keyword">None</span>
        self.right = <span class="keyword">None</span>

<span class="keyword">class</span> <span class="function">BST</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.root = <span class="keyword">None</span>
    
    <span class="keyword">def</span> <span class="function">insert</span>(self, val):
        <span class="keyword">if</span> <span class="keyword">not</span> self.root:
            self.root = TreeNode(val)
        <span class="keyword">else</span>:
            self._insert_recursive(self.root, val)
    
    <span class="keyword">def</span> <span class="function">_insert_recursive</span>(self, node, val):
        <span class="keyword">if</span> val < node.val:
            <span class="keyword">if</span> node.left:
                self._insert_recursive(node.left, val)
            <span class="keyword">else</span>:
                node.left = TreeNode(val)
        <span class="keyword">else</span>:
            <span class="keyword">if</span> node.right:
                self._insert_recursive(node.right, val)
            <span class="keyword">else</span>:
                node.right = TreeNode(val)
    
    <span class="keyword">def</span> <span class="function">search</span>(self, val):
        <span class="keyword">return</span> self._search_recursive(self.root, val)
    
    <span class="keyword">def</span> <span class="function">_search_recursive</span>(self, node, val):
        <span class="keyword">if</span> <span class="keyword">not</span> node:
            <span class="keyword">return</span> <span class="keyword">False</span>
        <span class="keyword">if</span> node.val == val:
            <span class="keyword">return</span> <span class="keyword">True</span>
        <span class="keyword">elif</span> val < node.val:
            <span class="keyword">return</span> self._search_recursive(node.left, val)
        <span class="keyword">else</span>:
            <span class="keyword">return</span> self._search_recursive(node.right, val)
    
    <span class="keyword">def</span> <span class="function">find_min</span>(self):
        <span class="keyword">if</span> <span class="keyword">not</span> self.root:
            <span class="keyword">return</span> <span class="keyword">None</span>
        current = self.root
        <span class="keyword">while</span> current.left:
            current = current.left
        <span class="keyword">return</span> current.val
    
    <span class="keyword">def</span> <span class="function">find_max</span>(self):
        <span class="keyword">if</span> <span class="keyword">not</span> self.root:
            <span class="keyword">return</span> <span class="keyword">None</span>
        current = self.root
        <span class="keyword">while</span> current.right:
            current = current.right
        <span class="keyword">return</span> current.val
    
    <span class="keyword">def</span> <span class="function">delete</span>(self, val):
        self.root = self._delete_recursive(self.root, val)
    
    <span class="keyword">def</span> <span class="function">_delete_recursive</span>(self, node, val):
        <span class="keyword">if</span> <span class="keyword">not</span> node:
            <span class="keyword">return</span> node
        
        <span class="keyword">if</span> val < node.val:
            node.left = self._delete_recursive(node.left, val)
        <span class="keyword">elif</span> val > node.val:
            node.right = self._delete_recursive(node.right, val)
        <span class="keyword">else</span>:
            <span class="comment"># Node with only one child or no child</span>
            <span class="keyword">if</span> <span class="keyword">not</span> node.left:
                <span class="keyword">return</span> node.right
            <span class="keyword">elif</span> <span class="keyword">not</span> node.right:
                <span class="keyword">return</span> node.left
            
            <span class="comment"># Node with two children - get inorder successor</span>
            temp = self._find_min_node(node.right)
            node.val = temp.val
            node.right = self._delete_recursive(node.right, temp.val)
        
        <span class="keyword">return</span> node
    
    <span class="keyword">def</span> <span class="function">_find_min_node</span>(self, node):
        current = node
        <span class="keyword">while</span> current.left:
            current = current.left
        <span class="keyword">return</span> current</code></pre>
                </div>
            </div>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Trie (Prefix Tree)</span>
                    <span class="complexity average">O(m) - m is word length</span>
                </div>
                <p class="ds-description">
                    Tree structure for storing strings efficiently. Each node represents a character, enabling fast
                    prefix searches and autocomplete.
                </p>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">TrieNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.children = {}  <span class="comment"># Dictionary of character -> TrieNode</span>
        self.is_end_of_word = <span class="keyword">False</span>
        self.word_count = <span class="number">0</span>  <span class="comment"># Track frequency</span>

<span class="keyword">class</span> <span class="function">Trie</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.root = TrieNode()
    
    <span class="keyword">def</span> <span class="function">insert</span>(self, word):
        node = self.root
        <span class="keyword">for</span> char <span class="keyword">in</span> word:
            <span class="keyword">if</span> char <span class="keyword">not in</span> node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = <span class="keyword">True</span>
        node.word_count += <span class="number">1</span>
    
    <span class="keyword">def</span> <span class="function">search</span>(self, word):
        node = self.root
        <span class="keyword">for</span> char <span class="keyword">in</span> word:
            <span class="keyword">if</span> char <span class="keyword">not in</span> node.children:
                <span class="keyword">return</span> <span class="keyword">False</span>
            node = node.children[char]
        <span class="keyword">return</span> node.is_end_of_word
    
    <span class="keyword">def</span> <span class="function">starts_with</span>(self, prefix):
        node = self.root
        <span class="keyword">for</span> char <span class="keyword">in</span> prefix:
            <span class="keyword">if</span> char <span class="keyword">not in</span> node.children:
                <span class="keyword">return</span> <span class="keyword">False</span>
            node = node.children[char]
        <span class="keyword">return</span> <span class="keyword">True</span>
    
    <span class="keyword">def</span> <span class="function">get_all_with_prefix</span>(self, prefix):
        <span class="comment"># Autocomplete functionality</span>
        node = self.root
        <span class="keyword">for</span> char <span class="keyword">in</span> prefix:
            <span class="keyword">if</span> char <span class="keyword">not in</span> node.children:
                <span class="keyword">return</span> []
            node = node.children[char]
        
        results = []
        self._dfs(node, prefix, results)
        <span class="keyword">return</span> results
    
    <span class="keyword">def</span> <span class="function">_dfs</span>(self, node, path, results):
        <span class="keyword">if</span> node.is_end_of_word:
            results.append((path, node.word_count))
        
        <span class="keyword">for</span> char, child <span class="keyword">in</span> node.children.items():
            self._dfs(child, path + char, results)
    
    <span class="keyword">def</span> <span class="function">delete</span>(self, word):
        <span class="keyword">def</span> <span class="function">_delete_helper</span>(node, word, index):
            <span class="keyword">if</span> index == len(word):
                <span class="comment"># Reached end of word</span>
                <span class="keyword">if</span> <span class="keyword">not</span> node.is_end_of_word:
                    <span class="keyword">return</span> <span class="keyword">False</span>
                node.is_end_of_word = <span class="keyword">False</span>
                <span class="comment"># Return True if node has no children</span>
                <span class="keyword">return</span> len(node.children) == <span class="number">0</span>
            
            char = word[index]
            <span class="keyword">if</span> char <span class="keyword">not in</span> node.children:
                <span class="keyword">return</span> <span class="keyword">False</span>
            
            should_delete = _delete_helper(node.children[char], word, index + <span class="number">1</span>)
            
            <span class="keyword">if</span> should_delete:
                <span class="keyword">del</span> node.children[char]
                <span class="comment"># Return True if current node has no children and is not end of another word</span>
                <span class="keyword">return</span> len(node.children) == <span class="number">0</span> <span class="keyword">and not</span> node.is_end_of_word
            
            <span class="keyword">return</span> <span class="keyword">False</span>
        
        _delete_helper(self.root, word, <span class="number">0</span>)</code></pre>
                </div>
            </div>
        </div>

        <!-- Graph Structures Section -->
        <div class="section">
            <h2 class="section-title">Graph Structures</h2>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Graph with Adjacency List</span>
                    <span class="complexity good">Space: O(V+E)</span>
                </div>
                <p class="ds-description">
                    Graph representation using dictionary of lists. Most efficient for sparse graphs where E << V¬≤. </p>
                        <div class="code-container">
                            <pre><code><span class="keyword">class</span> <span class="function">Graph</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, directed=<span class="keyword">False</span>):
        self.graph = {}  <span class="comment"># Adjacency list representation</span>
        self.directed = directed
    
    <span class="keyword">def</span> <span class="function">add_vertex</span>(self, vertex):
        <span class="keyword">if</span> vertex <span class="keyword">not in</span> self.graph:
            self.graph[vertex] = []
    
    <span class="keyword">def</span> <span class="function">add_edge</span>(self, u, v, weight=<span class="keyword">None</span>):
        <span class="comment"># Add vertices if they don't exist</span>
        self.add_vertex(u)
        self.add_vertex(v)
        
        <span class="comment"># Add edge with optional weight</span>
        <span class="keyword">if</span> weight <span class="keyword">is not</span> <span class="keyword">None</span>:
            self.graph[u].append((v, weight))
            <span class="keyword">if</span> <span class="keyword">not</span> self.directed:
                self.graph[v].append((u, weight))
        <span class="keyword">else</span>:
            self.graph[u].append(v)
            <span class="keyword">if</span> <span class="keyword">not</span> self.directed:
                self.graph[v].append(u)
    
    <span class="keyword">def</span> <span class="function">remove_edge</span>(self, u, v):
        <span class="keyword">if</span> u <span class="keyword">in</span> self.graph <span class="keyword">and</span> v <span class="keyword">in</span> self.graph[u]:
            self.graph[u].remove(v)
            <span class="keyword">if</span> <span class="keyword">not</span> self.directed:
                self.graph[v].remove(u)
    
    <span class="keyword">def</span> <span class="function">get_neighbors</span>(self, vertex):
        <span class="keyword">return</span> self.graph.get(vertex, [])
    
    <span class="keyword">def</span> <span class="function">has_edge</span>(self, u, v):
        <span class="keyword">if</span> u <span class="keyword">not in</span> self.graph:
            <span class="keyword">return</span> <span class="keyword">False</span>
        neighbors = self.graph[u]
        <span class="comment"># Handle both weighted and unweighted edges</span>
        <span class="keyword">if</span> neighbors <span class="keyword">and</span> isinstance(neighbors[<span class="number">0</span>], tuple):
            <span class="keyword">return</span> any(neighbor[<span class="number">0</span>] == v <span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors)
        <span class="keyword">return</span> v <span class="keyword">in</span> neighbors
    
    <span class="keyword">def</span> <span class="function">get_vertices</span>(self):
        <span class="keyword">return</span> list(self.graph.keys())
    
    <span class="keyword">def</span> <span class="function">get_edges</span>(self):
        edges = []
        <span class="keyword">for</span> u <span class="keyword">in</span> self.graph:
            <span class="keyword">for</span> v <span class="keyword">in</span> self.graph[u]:
                <span class="keyword">if</span> isinstance(v, tuple):
                    edges.append((u, v[<span class="number">0</span>], v[<span class="number">1</span>]))
                <span class="keyword">else</span>:
                    edges.append((u, v))
        <span class="keyword">return</span> edges</code></pre>
                        </div>
            </div>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Graph with Adjacency Matrix</span>
                    <span class="complexity poor">Space: O(V¬≤)</span>
                </div>
                <p class="ds-description">
                    2D array representation. Better for dense graphs or when checking edge existence frequently.
                    Provides O(1) edge lookup.
                </p>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">GraphMatrix</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, num_vertices, directed=<span class="keyword">False</span>):
        self.num_vertices = num_vertices
        self.directed = directed
        <span class="comment"># Initialize with infinity (no edge)</span>
        self.matrix = [[float(<span class="string">'inf'</span>)] * num_vertices 
                       <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_vertices)]
        <span class="comment"># Distance from vertex to itself is 0</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(num_vertices):
            self.matrix[i][i] = <span class="number">0</span>
    
    <span class="keyword">def</span> <span class="function">add_edge</span>(self, u, v, weight=<span class="number">1</span>):
        self.matrix[u][v] = weight
        <span class="keyword">if</span> <span class="keyword">not</span> self.directed:
            self.matrix[v][u] = weight
    
    <span class="keyword">def</span> <span class="function">remove_edge</span>(self, u, v):
        self.matrix[u][v] = float(<span class="string">'inf'</span>)
        <span class="keyword">if</span> <span class="keyword">not</span> self.directed:
            self.matrix[v][u] = float(<span class="string">'inf'</span>)
    
    <span class="keyword">def</span> <span class="function">has_edge</span>(self, u, v):
        <span class="keyword">return</span> self.matrix[u][v] != float(<span class="string">'inf'</span>)
    
    <span class="keyword">def</span> <span class="function">get_weight</span>(self, u, v):
        <span class="keyword">return</span> self.matrix[u][v]
    
    <span class="keyword">def</span> <span class="function">get_neighbors</span>(self, vertex):
        neighbors = []
        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_vertices):
            <span class="keyword">if</span> self.matrix[vertex][i] != float(<span class="string">'inf'</span>) <span class="keyword">and</span> i != vertex:
                neighbors.append((i, self.matrix[vertex][i]))
        <span class="keyword">return</span> neighbors
    
    <span class="keyword">def</span> <span class="function">display</span>(self):
        <span class="keyword">for</span> row <span class="keyword">in</span> self.matrix:
            <span class="keyword">print</span>([<span class="string">'‚àû'</span> <span class="keyword">if</span> x == float(<span class="string">'inf'</span>) <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> row])</code></pre>
                </div>
            </div>
        </div>

        <!-- Queue and Heap Structures Section -->
        <div class="section">
            <h2 class="section-title">Queue-Based & Heap Structures</h2>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Queue (FIFO)</span>
                    <span class="complexity good">O(1) enqueue/dequeue with deque</span>
                </div>
                <p class="ds-description">
                    First In, First Out data structure. Use collections.deque for O(1) operations at both ends.
                </p>
                <div class="code-container">
                    <pre><code><span class="keyword">from</span> collections <span class="keyword">import</span> deque

<span class="comment"># Using deque (double-ended queue) - most efficient</span>
queue = deque()

<span class="comment"># Enqueue (add to rear) - O(1)</span>
queue.append(<span class="number">1</span>)
queue.append(<span class="number">2</span>)
queue.append(<span class="number">3</span>)

<span class="comment"># Dequeue (remove from front) - O(1)</span>
first = queue.popleft()  <span class="comment"># Returns 1</span>

<span class="comment"># Peek at front without removing - O(1)</span>
front = queue[<span class="number">0</span>] <span class="keyword">if</span> queue <span class="keyword">else</span> <span class="keyword">None</span>

<span class="comment"># Check if empty</span>
is_empty = len(queue) == <span class="number">0</span>

<span class="comment"># Custom Queue Implementation (less efficient but educational)</span>
<span class="keyword">class</span> <span class="function">Queue</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.items = []
    
    <span class="keyword">def</span> <span class="function">enqueue</span>(self, item):
        self.items.append(item)  <span class="comment"># O(1)</span>
    
    <span class="keyword">def</span> <span class="function">dequeue</span>(self):
        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():
            <span class="keyword">return</span> self.items.pop(<span class="number">0</span>)  <span class="comment"># O(n) - inefficient!</span>
        <span class="keyword">raise</span> IndexError(<span class="string">"Queue is empty"</span>)
    
    <span class="keyword">def</span> <span class="function">peek</span>(self):
        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():
            <span class="keyword">return</span> self.items[<span class="number">0</span>]
        <span class="keyword">return</span> <span class="keyword">None</span>
    
    <span class="keyword">def</span> <span class="function">is_empty</span>(self):
        <span class="keyword">return</span> len(self.items) == <span class="number">0</span>
    
    <span class="keyword">def</span> <span class="function">size</span>(self):
        <span class="keyword">return</span> len(self.items)</code></pre>
                </div>
            </div>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Min Heap & Max Heap</span>
                    <span class="complexity average">O(log n) insert/delete</span>
                </div>
                <p class="ds-description">
                    Complete binary tree maintaining heap property. Python's heapq provides min heap; use negation for
                    max heap.
                </p>
                <div class="code-container">
                    <pre><code><span class="keyword">import</span> heapq

<span class="comment"># MIN HEAP (default in Python)</span>
min_heap = []

<span class="comment"># Insert - O(log n)</span>
heapq.heappush(min_heap, <span class="number">5</span>)
heapq.heappush(min_heap, <span class="number">3</span>)
heapq.heappush(min_heap, <span class="number">7</span>)

<span class="comment"># Extract min - O(log n)</span>
min_val = heapq.heappop(min_heap)  <span class="comment"># Returns 3</span>

<span class="comment"># Peek at min - O(1)</span>
min_val = min_heap[<span class="number">0</span>] <span class="keyword">if</span> min_heap <span class="keyword">else</span> <span class="keyword">None</span>

<span class="comment"># Convert list to heap in-place - O(n)</span>
nums = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>]
heapq.heapify(nums)  <span class="comment"># nums is now a min heap</span>

<span class="comment"># Get k smallest/largest elements</span>
k_smallest = heapq.nsmallest(<span class="number">3</span>, nums)  <span class="comment"># [1, 3, 5]</span>
k_largest = heapq.nlargest(<span class="number">3</span>, nums)   <span class="comment"># [9, 7, 5]</span>

<span class="comment"># MAX HEAP (using negation trick)</span>
max_heap = []
values = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>]

<span class="keyword">for</span> val <span class="keyword">in</span> values:
    heapq.heappush(max_heap, -val)  <span class="comment"># Negate for max heap</span>

<span class="comment"># Extract max</span>
max_val = -heapq.heappop(max_heap)  <span class="comment"># Returns 9</span>

<span class="comment"># PRIORITY QUEUE using heap with tuples</span>
pq = []
heapq.heappush(pq, (<span class="number">5</span>, <span class="string">"task1"</span>))  <span class="comment"># (priority, item)</span>
heapq.heappush(pq, (<span class="number">1</span>, <span class="string">"task2"</span>))
heapq.heappush(pq, (<span class="number">3</span>, <span class="string">"task3"</span>))

priority, task = heapq.heappop(pq)  <span class="comment"># Returns (1, "task2")</span></code></pre>
                </div>
            </div>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Custom Max Heap Implementation</span>
                    <span class="complexity average">O(log n) operations</span>
                </div>
                <p class="ds-description">
                    Complete implementation showing heap internals with bubble up/down operations.
                </p>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">MaxHeap</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.heap = []
    
    <span class="keyword">def</span> <span class="function">parent</span>(self, i):
        <span class="keyword">return</span> (i - <span class="number">1</span>) // <span class="number">2</span>
    
    <span class="keyword">def</span> <span class="function">left_child</span>(self, i):
        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>
    
    <span class="keyword">def</span> <span class="function">right_child</span>(self, i):
        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>
    
    <span class="keyword">def</span> <span class="function">insert</span>(self, val):
        self.heap.append(val)
        self._bubble_up(len(self.heap) - <span class="number">1</span>)
    
    <span class="keyword">def</span> <span class="function">_bubble_up</span>(self, i):
        <span class="keyword">while</span> i > <span class="number">0</span> <span class="keyword">and</span> self.heap[i] > self.heap[self.parent(i)]:
            <span class="comment"># Swap with parent</span>
            self.heap[i], self.heap[self.parent(i)] = \
                self.heap[self.parent(i)], self.heap[i]
            i = self.parent(i)
    
    <span class="keyword">def</span> <span class="function">extract_max</span>(self):
        <span class="keyword">if</span> <span class="keyword">not</span> self.heap:
            <span class="keyword">return</span> <span class="keyword">None</span>
        
        max_val = self.heap[<span class="number">0</span>]
        <span class="comment"># Move last element to root</span>
        self.heap[<span class="number">0</span>] = self.heap[-<span class="number">1</span>]
        self.heap.pop()
        
        <span class="keyword">if</span> self.heap:
            self._bubble_down(<span class="number">0</span>)
        
        <span class="keyword">return</span> max_val
    
    <span class="keyword">def</span> <span class="function">_bubble_down</span>(self, i):
        max_index = i
        left = self.left_child(i)
        right = self.right_child(i)
        
        <span class="comment"># Find the largest among node and its children</span>
        <span class="keyword">if</span> left < len(self.heap) <span class="keyword">and</span> self.heap[left] > self.heap[max_index]:
            max_index = left
        
        <span class="keyword">if</span> right < len(self.heap) <span class="keyword">and</span> self.heap[right] > self.heap[max_index]:
            max_index = right
        
        <span class="comment"># If largest is not current node, swap and continue</span>
        <span class="keyword">if</span> max_index != i:
            self.heap[i], self.heap[max_index] = self.heap[max_index], self.heap[i]
            self._bubble_down(max_index)
    
    <span class="keyword">def</span> <span class="function">peek</span>(self):
        <span class="keyword">return</span> self.heap[<span class="number">0</span>] <span class="keyword">if</span> self.heap <span class="keyword">else</span> <span class="keyword">None</span></code></pre>
                </div>
            </div>
        </div>

        <!-- Tree Traversals Section -->
        <div class="section">
            <h2 class="section-title">Tree Traversal Methods</h2>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">All Tree Traversals</span>
                    <span class="complexity average">O(n) time, O(h) space</span>
                </div>
                <p class="ds-description">
                    Different ways to visit all nodes: Inorder (Left-Root-Right), Preorder (Root-Left-Right), Postorder
                    (Left-Right-Root), and Level-order (BFS).
                </p>
                <div class="code-container">
                    <pre><code><span class="comment"># Tree node definition</span>
<span class="keyword">class</span> <span class="function">TreeNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, val):
        self.val = val
        self.left = <span class="keyword">None</span>
        self.right = <span class="keyword">None</span>

<span class="comment"># INORDER TRAVERSAL: Left -> Root -> Right</span>
<span class="comment"># For BST, gives sorted order</span>
<span class="keyword">def</span> <span class="function">inorder_recursive</span>(root):
    result = []
    <span class="keyword">def</span> <span class="function">traverse</span>(node):
        <span class="keyword">if</span> node:
            traverse(node.left)
            result.append(node.val)
            traverse(node.right)
    traverse(root)
    <span class="keyword">return</span> result

<span class="keyword">def</span> <span class="function">inorder_iterative</span>(root):
    result = []
    stack = []
    current = root
    
    <span class="keyword">while</span> stack <span class="keyword">or</span> current:
        <span class="keyword">while</span> current:
            stack.append(current)
            current = current.left
        current = stack.pop()
        result.append(current.val)
        current = current.right
    
    <span class="keyword">return</span> result

<span class="comment"># PREORDER TRAVERSAL: Root -> Left -> Right</span>
<span class="comment"># Useful for copying trees or serialization</span>
<span class="keyword">def</span> <span class="function">preorder_recursive</span>(root):
    result = []
    <span class="keyword">def</span> <span class="function">traverse</span>(node):
        <span class="keyword">if</span> node:
            result.append(node.val)
            traverse(node.left)
            traverse(node.right)
    traverse(root)
    <span class="keyword">return</span> result

<span class="keyword">def</span> <span class="function">preorder_iterative</span>(root):
    <span class="keyword">if</span> <span class="keyword">not</span> root:
        <span class="keyword">return</span> []
    
    result = []
    stack = [root]
    
    <span class="keyword">while</span> stack:
        node = stack.pop()
        result.append(node.val)
        <span class="comment"># Push right first so left is processed first</span>
        <span class="keyword">if</span> node.right:
            stack.append(node.right)
        <span class="keyword">if</span> node.left:
            stack.append(node.left)
    
    <span class="keyword">return</span> result

<span class="comment"># POSTORDER TRAVERSAL: Left -> Right -> Root</span>
<span class="comment"># Useful for deletion or calculating sizes</span>
<span class="keyword">def</span> <span class="function">postorder_recursive</span>(root):
    result = []
    <span class="keyword">def</span> <span class="function">traverse</span>(node):
        <span class="keyword">if</span> node:
            traverse(node.left)
            traverse(node.right)
            result.append(node.val)
    traverse(root)
    <span class="keyword">return</span> result

<span class="keyword">def</span> <span class="function">postorder_iterative</span>(root):
    <span class="keyword">if</span> <span class="keyword">not</span> root:
        <span class="keyword">return</span> []
    
    result = []
    stack = [root]
    
    <span class="comment"># Use two stacks or reverse preorder with modified order</span>
    <span class="keyword">while</span> stack:
        node = stack.pop()
        result.append(node.val)
        <span class="keyword">if</span> node.left:
            stack.append(node.left)
        <span class="keyword">if</span> node.right:
            stack.append(node.right)
    
    <span class="keyword">return</span> result[::-<span class="number">1</span>]  <span class="comment"># Reverse the result</span>

<span class="comment"># LEVEL-ORDER TRAVERSAL (BFS)</span>
<span class="keyword">from</span> collections <span class="keyword">import</span> deque

<span class="keyword">def</span> <span class="function">level_order</span>(root):
    <span class="keyword">if</span> <span class="keyword">not</span> root:
        <span class="keyword">return</span> []
    
    result = []
    queue = deque([root])
    
    <span class="keyword">while</span> queue:
        level_size = len(queue)
        level = []
        
        <span class="keyword">for</span> _ <span class="keyword">in</span> range(level_size):
            node = queue.popleft()
            level.append(node.val)
            
            <span class="keyword">if</span> node.left:
                queue.append(node.left)
            <span class="keyword">if</span> node.right:
                queue.append(node.right)
        
        result.append(level)
    
    <span class="keyword">return</span> result</code></pre>
                </div>
            </div>
        </div>

        <!-- Search Algorithms Section -->
        <div class="section">
            <h2 class="section-title">Graph Search Algorithms</h2>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Depth-First Search (DFS)</span>
                    <span class="complexity average">O(V+E) time, O(V) space</span>
                </div>
                <p class="ds-description">
                    Explores as far as possible along each branch before backtracking. Uses stack (explicit or call
                    stack).
                </p>
                <div class="code-container">
                    <pre><code><span class="comment"># Basic DFS - Recursive</span>
<span class="keyword">def</span> <span class="function">dfs_recursive</span>(graph, start, visited=<span class="keyword">None</span>):
    <span class="keyword">if</span> visited <span class="keyword">is</span> <span class="keyword">None</span>:
        visited = set()
    
    visited.add(start)
    <span class="keyword">print</span>(start, end=<span class="string">' '</span>)
    
    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[start]:
        <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
            dfs_recursive(graph, neighbor, visited)
    
    <span class="keyword">return</span> visited

<span class="comment"># DFS - Iterative with explicit stack</span>
<span class="keyword">def</span> <span class="function">dfs_iterative</span>(graph, start):
    visited = set()
    stack = [start]
    
    <span class="keyword">while</span> stack:
        vertex = stack.pop()
        
        <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
            visited.add(vertex)
            <span class="keyword">print</span>(vertex, end=<span class="string">' '</span>)
            
            <span class="comment"># Add unvisited neighbors</span>
            <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[vertex]:
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                    stack.append(neighbor)
    
    <span class="keyword">return</span> visited

<span class="comment"># DFS to find path between two nodes</span>
<span class="keyword">def</span> <span class="function">dfs_find_path</span>(graph, start, target, path=[]):
    path = path + [start]
    
    <span class="keyword">if</span> start == target:
        <span class="keyword">return</span> path
    
    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[start]:
        <span class="keyword">if</span> neighbor <span class="keyword">not in</span> path:
            new_path = dfs_find_path(graph, neighbor, target, path)
            <span class="keyword">if</span> new_path:
                <span class="keyword">return</span> new_path
    
    <span class="keyword">return</span> <span class="keyword">None</span>

<span class="comment"># DFS to detect cycle in directed graph</span>
<span class="keyword">def</span> <span class="function">has_cycle_dfs</span>(graph):
    WHITE = <span class="number">0</span>  <span class="comment"># Not visited</span>
    GRAY = <span class="number">1</span>   <span class="comment"># Being processed (in current path)</span>
    BLACK = <span class="number">2</span>  <span class="comment"># Fully processed</span>
    
    colors = {node: WHITE <span class="keyword">for</span> node <span class="keyword">in</span> graph}
    
    <span class="keyword">def</span> <span class="function">visit</span>(node):
        <span class="keyword">if</span> colors[node] == GRAY:
            <span class="keyword">return</span> <span class="keyword">True</span>  <span class="comment"># Back edge found - cycle!</span>
        
        <span class="keyword">if</span> colors[node] == BLACK:
            <span class="keyword">return</span> <span class="keyword">False</span>  <span class="comment"># Already processed</span>
        
        colors[node] = GRAY
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:
            <span class="keyword">if</span> visit(neighbor):
                <span class="keyword">return</span> <span class="keyword">True</span>
        
        colors[node] = BLACK
        <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="keyword">for</span> node <span class="keyword">in</span> graph:
        <span class="keyword">if</span> colors[node] == WHITE:
            <span class="keyword">if</span> visit(node):
                <span class="keyword">return</span> <span class="keyword">True</span>
    
    <span class="keyword">return</span> <span class="keyword">False</span>

<span class="comment"># DFS for topological sort</span>
<span class="keyword">def</span> <span class="function">topological_sort_dfs</span>(graph):
    visited = set()
    stack = []
    
    <span class="keyword">def</span> <span class="function">dfs</span>(node):
        visited.add(node)
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.get(node, []):
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                dfs(neighbor)
        stack.append(node)  <span class="comment"># Add after visiting all dependencies</span>
    
    <span class="keyword">for</span> node <span class="keyword">in</span> graph:
        <span class="keyword">if</span> node <span class="keyword">not in</span> visited:
            dfs(node)
    
    <span class="keyword">return</span> stack[::-<span class="number">1</span>]  <span class="comment"># Reverse to get correct order</span></code></pre>
                </div>
            </div>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Breadth-First Search (BFS)</span>
                    <span class="complexity average">O(V+E) time, O(V) space</span>
                </div>
                <p class="ds-description">
                    Explores all neighbors at current depth before moving deeper. Uses queue. Finds shortest path in
                    unweighted graphs.
                </p>
                <div class="code-container">
                    <pre><code><span class="keyword">from</span> collections <span class="keyword">import</span> deque

<span class="comment"># Basic BFS</span>
<span class="keyword">def</span> <span class="function">bfs</span>(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    
    <span class="keyword">while</span> queue:
        vertex = queue.popleft()
        <span class="keyword">print</span>(vertex, end=<span class="string">' '</span>)
        
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[vertex]:
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    <span class="keyword">return</span> visited

<span class="comment"># BFS to find shortest path (unweighted graph)</span>
<span class="keyword">def</span> <span class="function">bfs_shortest_path</span>(graph, start, target):
    queue = deque([(start, [start])])
    visited = {start}
    
    <span class="keyword">while</span> queue:
        vertex, path = queue.popleft()
        
        <span class="keyword">if</span> vertex == target:
            <span class="keyword">return</span> path
        
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[vertex]:
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    <span class="keyword">return</span> <span class="keyword">None</span>  <span class="comment"># No path found</span>

<span class="comment"># BFS by levels (useful for tree problems)</span>
<span class="keyword">def</span> <span class="function">bfs_by_levels</span>(graph, start):
    <span class="keyword">if</span> start <span class="keyword">not in</span> graph:
        <span class="keyword">return</span> []
    
    levels = []
    visited = {start}
    queue = deque([start])
    
    <span class="keyword">while</span> queue:
        level_size = len(queue)
        current_level = []
        
        <span class="keyword">for</span> _ <span class="keyword">in</span> range(level_size):
            vertex = queue.popleft()
            current_level.append(vertex)
            
            <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[vertex]:
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        levels.append(current_level)
    
    <span class="keyword">return</span> levels

<span class="comment"># BFS to find all nodes at distance k</span>
<span class="keyword">def</span> <span class="function">nodes_at_distance_k</span>(graph, start, k):
    <span class="keyword">if</span> k == <span class="number">0</span>:
        <span class="keyword">return</span> [start]
    
    visited = {start}
    queue = deque([(start, <span class="number">0</span>)])
    result = []
    
    <span class="keyword">while</span> queue:
        vertex, distance = queue.popleft()
        
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[vertex]:
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                visited.add(neighbor)
                new_distance = distance + <span class="number">1</span>
                
                <span class="keyword">if</span> new_distance == k:
                    result.append(neighbor)
                <span class="keyword">elif</span> new_distance < k:
                    queue.append((neighbor, new_distance))
    
    <span class="keyword">return</span> result

<span class="comment"># Check if graph is bipartite using BFS</span>
<span class="keyword">def</span> <span class="function">is_bipartite_bfs</span>(graph):
    color = {}
    
    <span class="keyword">for</span> start <span class="keyword">in</span> graph:
        <span class="keyword">if</span> start <span class="keyword">not in</span> color:
            queue = deque([start])
            color[start] = <span class="number">0</span>
            
            <span class="keyword">while</span> queue:
                vertex = queue.popleft()
                
                <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[vertex]:
                    <span class="keyword">if</span> neighbor <span class="keyword">not in</span> color:
                        color[neighbor] = <span class="number">1</span> - color[vertex]
                        queue.append(neighbor)
                    <span class="keyword">elif</span> color[neighbor] == color[vertex]:
                        <span class="keyword">return</span> <span class="keyword">False</span>  <span class="comment"># Same color - not bipartite</span>
    
    <span class="keyword">return</span> <span class="keyword">True</span></code></pre>
                </div>
            </div>
        </div>

        <!-- Linked Lists Section -->
        <div class="section">
            <h2 class="section-title">Linked List Structures</h2>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Singly Linked List</span>
                    <span class="complexity average">O(1) insert at head, O(n) search</span>
                </div>
                <p class="ds-description">
                    Linear collection where each node points to the next. Good for stack implementation and when
                    frequent insertion/deletion at head.
                </p>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">ListNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, val=<span class="number">0</span>, next=<span class="keyword">None</span>):
        self.val = val
        self.next = next

<span class="keyword">class</span> <span class="function">LinkedList</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.head = <span class="keyword">None</span>
        self.size = <span class="number">0</span>
    
    <span class="keyword">def</span> <span class="function">prepend</span>(self, val):
        <span class="comment"># Add to beginning - O(1)</span>
        new_node = ListNode(val)
        new_node.next = self.head
        self.head = new_node
        self.size += <span class="number">1</span>
    
    <span class="keyword">def</span> <span class="function">append</span>(self, val):
        <span class="comment"># Add to end - O(n)</span>
        new_node = ListNode(val)
        <span class="keyword">if</span> <span class="keyword">not</span> self.head:
            self.head = new_node
        <span class="keyword">else</span>:
            current = self.head
            <span class="keyword">while</span> current.next:
                current = current.next
            current.next = new_node
        self.size += <span class="number">1</span>
    
    <span class="keyword">def</span> <span class="function">delete_value</span>(self, val):
        <span class="comment"># Delete first occurrence - O(n)</span>
        <span class="keyword">if</span> <span class="keyword">not</span> self.head:
            <span class="keyword">return</span>
        
        <span class="keyword">if</span> self.head.val == val:
            self.head = self.head.next
            self.size -= <span class="number">1</span>
            <span class="keyword">return</span>
        
        current = self.head
        <span class="keyword">while</span> current.next:
            <span class="keyword">if</span> current.next.val == val:
                current.next = current.next.next
                self.size -= <span class="number">1</span>
                <span class="keyword">return</span>
            current = current.next
    
    <span class="keyword">def</span> <span class="function">find_middle</span>(self):
        <span class="comment"># Find middle using slow/fast pointers - O(n)</span>
        <span class="keyword">if</span> <span class="keyword">not</span> self.head:
            <span class="keyword">return</span> <span class="keyword">None</span>
        
        slow = fast = self.head
        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:
            slow = slow.next
            fast = fast.next.next
        <span class="keyword">return</span> slow.val
    
    <span class="keyword">def</span> <span class="function">has_cycle</span>(self):
        <span class="comment"># Floyd's cycle detection - O(n)</span>
        <span class="keyword">if</span> <span class="keyword">not</span> self.head:
            <span class="keyword">return</span> <span class="keyword">False</span>
        
        slow = fast = self.head
        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:
            slow = slow.next
            fast = fast.next.next
            <span class="keyword">if</span> slow == fast:
                <span class="keyword">return</span> <span class="keyword">True</span>
        <span class="keyword">return</span> <span class="keyword">False</span>

<span class="comment"># REVERSE LINKED LIST - Multiple approaches</span>
<span class="keyword">def</span> <span class="function">reverse_iterative</span>(head):
    <span class="comment"># O(n) time, O(1) space</span>
    prev = <span class="keyword">None</span>
    current = head
    
    <span class="keyword">while</span> current:
        next_temp = current.next  <span class="comment"># Store next</span>
        current.next = prev       <span class="comment"># Reverse pointer</span>
        prev = current            <span class="comment"># Move prev forward</span>
        current = next_temp       <span class="comment"># Move current forward</span>
    
    <span class="keyword">return</span> prev  <span class="comment"># New head</span>

<span class="keyword">def</span> <span class="function">reverse_recursive</span>(head):
    <span class="comment"># O(n) time, O(n) space (call stack)</span>
    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:
        <span class="keyword">return</span> head
    
    new_head = reverse_recursive(head.next)
    head.next.next = head
    head.next = <span class="keyword">None</span>
    
    <span class="keyword">return</span> new_head</code></pre>
                </div>
            </div>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Doubly Linked List</span>
                    <span class="complexity average">O(1) insert/delete at both ends</span>
                </div>
                <p class="ds-description">
                    Each node has references to both next and previous nodes. Good for implementing deque and LRU cache.
                </p>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">DLLNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, val=<span class="number">0</span>):
        self.val = val
        self.prev = <span class="keyword">None</span>
        self.next = <span class="keyword">None</span>

<span class="keyword">class</span> <span class="function">DoublyLinkedList</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="comment"># Use sentinel nodes for cleaner code</span>
        self.head = DLLNode()  <span class="comment"># Dummy head</span>
        self.tail = DLLNode()  <span class="comment"># Dummy tail</span>
        self.head.next = self.tail
        self.tail.prev = self.head
        self.size = <span class="number">0</span>
    
    <span class="keyword">def</span> <span class="function">append</span>(self, val):
        <span class="comment"># Add to end - O(1)</span>
        new_node = DLLNode(val)
        prev_node = self.tail.prev
        
        prev_node.next = new_node
        new_node.prev = prev_node
        new_node.next = self.tail
        self.tail.prev = new_node
        
        self.size += <span class="number">1</span>
    
    <span class="keyword">def</span> <span class="function">prepend</span>(self, val):
        <span class="comment"># Add to beginning - O(1)</span>
        new_node = DLLNode(val)
        next_node = self.head.next
        
        self.head.next = new_node
        new_node.prev = self.head
        new_node.next = next_node
        next_node.prev = new_node
        
        self.size += <span class="number">1</span>
    
    <span class="keyword">def</span> <span class="function">delete_node</span>(self, node):
        <span class="comment"># Delete given node - O(1)</span>
        <span class="keyword">if</span> node == self.head <span class="keyword">or</span> node == self.tail:
            <span class="keyword">return</span>  <span class="comment"># Don't delete sentinels</span>
        
        prev_node = node.prev
        next_node = node.next
        prev_node.next = next_node
        next_node.prev = prev_node
        
        self.size -= <span class="number">1</span>
    
    <span class="keyword">def</span> <span class="function">pop_left</span>(self):
        <span class="comment"># Remove from beginning - O(1)</span>
        <span class="keyword">if</span> self.size == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="keyword">None</span>
        
        node = self.head.next
        self.delete_node(node)
        <span class="keyword">return</span> node.val
    
    <span class="keyword">def</span> <span class="function">pop_right</span>(self):
        <span class="comment"># Remove from end - O(1)</span>
        <span class="keyword">if</span> self.size == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="keyword">None</span>
        
        node = self.tail.prev
        self.delete_node(node)
        <span class="keyword">return</span> node.val</code></pre>
                </div>
            </div>
        </div>

        <!-- Sorting Algorithms Section -->
        <div class="section">
            <h2 class="section-title">Sorting Algorithms</h2>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Merge Sort</span>
                    <span class="complexity good">O(n log n) always, O(n) space</span>
                </div>
                <p class="ds-description">
                    Divide-and-conquer algorithm. Stable sort that divides array in half, sorts recursively, then merges
                    sorted halves.
                </p>
                <div class="code-container">
                    <pre><code><span class="comment"># Classic Merge Sort - Creates new arrays</span>
<span class="keyword">def</span> <span class="function">merge_sort</span>(arr):
    <span class="keyword">if</span> len(arr) <= <span class="number">1</span>:
        <span class="keyword">return</span> arr
    
    <span class="comment"># Divide array into two halves</span>
    mid = len(arr) // <span class="number">2</span>
    left = arr[:mid]
    right = arr[mid:]
    
    <span class="comment"># Recursively sort both halves</span>
    left = merge_sort(left)
    right = merge_sort(right)
    
    <span class="comment"># Merge sorted halves</span>
    <span class="keyword">return</span> merge(left, right)

<span class="keyword">def</span> <span class="function">merge</span>(left, right):
    result = []
    i = j = <span class="number">0</span>
    
    <span class="comment"># Merge two sorted arrays</span>
    <span class="keyword">while</span> i < len(left) <span class="keyword">and</span> j < len(right):
        <span class="keyword">if</span> left[i] <= right[j]:
            result.append(left[i])
            i += <span class="number">1</span>
        <span class="keyword">else</span>:
            result.append(right[j])
            j += <span class="number">1</span>
    
    <span class="comment"># Add remaining elements</span>
    result.extend(left[i:])
    result.extend(right[j:])
    
    <span class="keyword">return</span> result

<span class="comment"># In-place Merge Sort (modifies original array)</span>
<span class="keyword">def</span> <span class="function">merge_sort_inplace</span>(arr):
    <span class="keyword">def</span> <span class="function">merge_inplace</span>(arr, left, mid, right):
        <span class="comment"># Create temp arrays</span>
        left_arr = arr[left:mid + <span class="number">1</span>]
        right_arr = arr[mid + <span class="number">1</span>:right + <span class="number">1</span>]
        
        i = j = <span class="number">0</span>
        k = left
        
        <span class="keyword">while</span> i < len(left_arr) <span class="keyword">and</span> j < len(right_arr):
            <span class="keyword">if</span> left_arr[i] <= right_arr[j]:
                arr[k] = left_arr[i]
                i += <span class="number">1</span>
            <span class="keyword">else</span>:
                arr[k] = right_arr[j]
                j += <span class="number">1</span>
            k += <span class="number">1</span>
        
        <span class="keyword">while</span> i < len(left_arr):
            arr[k] = left_arr[i]
            i += <span class="number">1</span>
            k += <span class="number">1</span>
        
        <span class="keyword">while</span> j < len(right_arr):
            arr[k] = right_arr[j]
            j += <span class="number">1</span>
            k += <span class="number">1</span>
    
    <span class="keyword">def</span> <span class="function">sort</span>(arr, left, right):
        <span class="keyword">if</span> left < right:
            mid = (left + right) // <span class="number">2</span>
            sort(arr, left, mid)
            sort(arr, mid + <span class="number">1</span>, right)
            merge_inplace(arr, left, mid, right)
    
    sort(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>)
    <span class="keyword">return</span> arr

<span class="comment"># Merge k sorted arrays</span>
<span class="keyword">import</span> heapq

<span class="keyword">def</span> <span class="function">merge_k_sorted</span>(arrays):
    result = []
    heap = []
    
    <span class="comment"># Initialize heap with first element from each array</span>
    <span class="keyword">for</span> i, arr <span class="keyword">in</span> enumerate(arrays):
        <span class="keyword">if</span> arr:
            heapq.heappush(heap, (arr[<span class="number">0</span>], i, <span class="number">0</span>))
    
    <span class="keyword">while</span> heap:
        val, arr_idx, elem_idx = heapq.heappop(heap)
        result.append(val)
        
        <span class="comment"># Add next element from same array if exists</span>
        <span class="keyword">if</span> elem_idx + <span class="number">1</span> < len(arrays[arr_idx]):
            heapq.heappush(heap, 
                (arrays[arr_idx][elem_idx + <span class="number">1</span>], arr_idx, elem_idx + <span class="number">1</span>))
    
    <span class="keyword">return</span> result</code></pre>
                </div>
            </div>

            <div class="data-structure">
                <div class="ds-header">
                    <span class="ds-title">Binary Insertion Sort</span>
                    <span class="complexity average">O(n¬≤) shifts, O(n log n) comparisons</span>
                </div>
                <p class="ds-description">
                    Insertion sort optimized with binary search to find insertion position. Reduces comparisons but not
                    shifts.
                </p>
                <div class="code-container">
                    <pre><code><span class="keyword">def</span> <span class="function">binary_search_position</span>(arr, val, left, right):
    <span class="comment"># Find position where val should be inserted</span>
    <span class="keyword">while</span> left <= right:
        mid = (left + right) // <span class="number">2</span>
        <span class="keyword">if</span> arr[mid] == val:
            <span class="keyword">return</span> mid + <span class="number">1</span>
        <span class="keyword">elif</span> arr[mid] < val:
            left = mid + <span class="number">1</span>
        <span class="keyword">else</span>:
            right = mid - <span class="number">1</span>
    <span class="keyword">return</span> left

<span class="keyword">def</span> <span class="function">binary_insertion_sort</span>(arr):
    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):
        key = arr[i]
        left = <span class="number">0</span>
        right = i - <span class="number">1</span>
        
        <span class="comment"># Find insertion position using binary search</span>
        pos = binary_search_position(arr, key, left, right)
        
        <span class="comment"># Shift elements and insert</span>
        arr[pos + <span class="number">1</span>:i + <span class="number">1</span>] = arr[pos:i]
        arr[pos] = key
    
    <span class="keyword">return</span> arr

<span class="comment"># Python's bisect module provides this functionality</span>
<span class="keyword">import</span> bisect

<span class="keyword">def</span> <span class="function">binary_insertion_sort_bisect</span>(arr):
    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):
        key = arr[i]
        <span class="comment"># Find insertion point</span>
        pos = bisect.bisect_left(arr, key, <span class="number">0</span>, i)
        <span class="comment"># Shift and insert</span>
        arr[pos + <span class="number">1</span>:i + <span class="number">1</span>] = arr[pos:i]
        arr[pos] = key
    <span class="keyword">return</span> arr

<span class="comment"># Regular insertion sort for comparison</span>
<span class="keyword">def</span> <span class="function">insertion_sort</span>(arr):
    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):
        key = arr[i]
        j = i - <span class="number">1</span>
        
        <span class="comment"># Linear search and shift</span>
        <span class="keyword">while</span> j >= <span class="number">0</span> <span class="keyword">and</span> arr[j] > key:
            arr[j + <span class="number">1</span>] = arr[j]
            j -= <span class="number">1</span>
        
        arr[j + <span class="number">1</span>] = key
    
    <span class="keyword">return</span> arr</code></pre>
                </div>
            </div>
        </div>

        <!-- Time Complexity Reference -->
        <div class="section">
            <h2 class="section-title">‚è±Ô∏è Time Complexity Quick Reference</h2>

            <style>
                .complexity-table {
                    width: 100%;
                    border-collapse: collapse;
                    margin: 20px 0;
                    font-size: 0.95rem;
                }

                .complexity-table th {
                    background: #667eea;
                    color: white;
                    padding: 12px;
                    text-align: left;
                    font-weight: bold;
                }

                .complexity-table td {
                    padding: 10px 12px;
                    border-bottom: 1px solid #e0e0e0;
                }

                .complexity-table tr:nth-child(even) {
                    background: #f8f9fa;
                }

                .complexity-table tr:hover {
                    background: #e8ecff;
                }

                .time-o1 {
                    color: #28a745;
                    font-weight: bold;
                }

                .time-ologn {
                    color: #17a2b8;
                    font-weight: bold;
                }

                .time-on {
                    color: #ffc107;
                    font-weight: bold;
                }

                .time-onlogn {
                    color: #fd7e14;
                    font-weight: bold;
                }

                .time-on2 {
                    color: #dc3545;
                    font-weight: bold;
                }
            </style>

            <h3 style="color: #495057; margin-top: 20px; margin-bottom: 15px;">Data Structure Operations</h3>
            <table class="complexity-table">
                <thead>
                    <tr>
                        <th>Data Structure</th>
                        <th>Access</th>
                        <th>Search</th>
                        <th>Insert</th>
                        <th>Delete</th>
                        <th>Space</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Array</strong></td>
                        <td class="time-o1">O(1)</td>
                        <td class="time-on">O(n)</td>
                        <td class="time-on">O(n)</td>
                        <td class="time-on">O(n)</td>
                        <td class="time-on">O(n)</td>
                    </tr>
                    <tr>
                        <td><strong>Dynamic Array (Python list)</strong></td>
                        <td class="time-o1">O(1)</td>
                        <td class="time-on">O(n)</td>
                        <td class="time-o1">O(1)* amortized</td>
                        <td class="time-on">O(n)</td>
                        <td class="time-on">O(n)</td>
                    </tr>
                    <tr>
                        <td><strong>Linked List</strong></td>
                        <td class="time-on">O(n)</td>
                        <td class="time-on">O(n)</td>
                        <td class="time-o1">O(1)**</td>
                        <td class="time-o1">O(1)**</td>
                        <td class="time-on">O(n)</td>
                    </tr>
                    <tr>
                        <td><strong>Doubly Linked List</strong></td>
                        <td class="time-on">O(n)</td>
                        <td class="time-on">O(n)</td>
                        <td class="time-o1">O(1)**</td>
                        <td class="time-o1">O(1)**</td>
                        <td class="time-on">O(n)</td>
                    </tr>
                    <tr>
                        <td><strong>Stack</strong></td>
                        <td class="time-on">O(n)</td>
                        <td class="time-on">O(n)</td>
                        <td class="time-o1">O(1)</td>
                        <td class="time-o1">O(1)</td>
                        <td class="time-on">O(n)</td>
                    </tr>
                    <tr>
                        <td><strong>Queue</strong></td>
                        <td class="time-on">O(n)</td>
                        <td class="time-on">O(n)</td>
                        <td class="time-o1">O(1)</td>
                        <td class="time-o1">O(1)</td>
                        <td class="time-on">O(n)</td>
                    </tr>
                    <tr>
                        <td><strong>Hash Table (dict/set)</strong></td>
                        <td class="time-o1">O(1)* avg</td>
                        <td class="time-o1">O(1)* avg</td>
                        <td class="time-o1">O(1)* avg</td>
                        <td class="time-o1">O(1)* avg</td>
                        <td class="time-on">O(n)</td>
                    </tr>
                    <tr>
                        <td><strong>Binary Search Tree</strong></td>
                        <td class="time-ologn">O(log n)* avg</td>
                        <td class="time-ologn">O(log n)* avg</td>
                        <td class="time-ologn">O(log n)* avg</td>
                        <td class="time-ologn">O(log n)* avg</td>
                        <td class="time-on">O(n)</td>
                    </tr>
                    <tr>
                        <td><strong>AVL Tree</strong></td>
                        <td class="time-ologn">O(log n)</td>
                        <td class="time-ologn">O(log n)</td>
                        <td class="time-ologn">O(log n)</td>
                        <td class="time-ologn">O(log n)</td>
                        <td class="time-on">O(n)</td>
                    </tr>
                    <tr>
                        <td><strong>Binary Heap</strong></td>
                        <td class="time-o1">O(1) min/max</td>
                        <td class="time-on">O(n)</td>
                        <td class="time-ologn">O(log n)</td>
                        <td class="time-ologn">O(log n)</td>
                        <td class="time-on">O(n)</td>
                    </tr>
                    <tr>
                        <td><strong>Graph (Adjacency List)</strong></td>
                        <td>-</td>
                        <td class="time-on">O(V+E)</td>
                        <td class="time-o1">O(1)</td>
                        <td class="time-on">O(V)</td>
                        <td class="time-on">O(V+E)</td>
                    </tr>
                    <tr>
                        <td><strong>Graph (Adjacency Matrix)</strong></td>
                        <td class="time-o1">O(1)</td>
                        <td class="time-on2">O(V¬≤)</td>
                        <td class="time-o1">O(1)</td>
                        <td class="time-o1">O(1)</td>
                        <td class="time-on2">O(V¬≤)</td>
                    </tr>
                    <tr>
                        <td><strong>Trie</strong></td>
                        <td class="time-on">O(m)</td>
                        <td class="time-on">O(m)</td>
                        <td class="time-on">O(m)</td>
                        <td class="time-on">O(m)</td>
                        <td class="time-on">O(n√óm)</td>
                    </tr>
                </tbody>
            </table>
            <p style="color: #6c757d; font-size: 0.9rem; margin-top: 10px;">
                * Average case (worst case may be O(n))<br>
                ** With pointer/reference to node<br>
                m = length of string/key, n = number of items, V = vertices, E = edges
            </p>

            <h3 style="color: #495057; margin-top: 30px; margin-bottom: 15px;">Sorting Algorithms</h3>
            <table class="complexity-table">
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Best Case</th>
                        <th>Average Case</th>
                        <th>Worst Case</th>
                        <th>Space</th>
                        <th>Stable?</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Bubble Sort</strong></td>
                        <td class="time-on">O(n)</td>
                        <td class="time-on2">O(n¬≤)</td>
                        <td class="time-on2">O(n¬≤)</td>
                        <td class="time-o1">O(1)</td>
                        <td>‚úì</td>
                    </tr>
                    <tr>
                        <td><strong>Selection Sort</strong></td>
                        <td class="time-on2">O(n¬≤)</td>
                        <td class="time-on2">O(n¬≤)</td>
                        <td class="time-on2">O(n¬≤)</td>
                        <td class="time-o1">O(1)</td>
                        <td>‚úó</td>
                    </tr>
                    <tr>
                        <td><strong>Insertion Sort</strong></td>
                        <td class="time-on">O(n)</td>
                        <td class="time-on2">O(n¬≤)</td>
                        <td class="time-on2">O(n¬≤)</td>
                        <td class="time-o1">O(1)</td>
                        <td>‚úì</td>
                    </tr>
                    <tr>
                        <td><strong>Merge Sort</strong></td>
                        <td class="time-onlogn">O(n log n)</td>
                        <td class="time-onlogn">O(n log n)</td>
                        <td class="time-onlogn">O(n log n)</td>
                        <td class="time-on">O(n)</td>
                        <td>‚úì</td>
                    </tr>
                    <tr>
                        <td><strong>Quick Sort</strong></td>
                        <td class="time-onlogn">O(n log n)</td>
                        <td class="time-onlogn">O(n log n)</td>
                        <td class="time-on2">O(n¬≤)</td>
                        <td class="time-ologn">O(log n)</td>
                        <td>‚úó</td>
                    </tr>
                    <tr>
                        <td><strong>Heap Sort</strong></td>
                        <td class="time-onlogn">O(n log n)</td>
                        <td class="time-onlogn">O(n log n)</td>
                        <td class="time-onlogn">O(n log n)</td>
                        <td class="time-o1">O(1)</td>
                        <td>‚úó</td>
                    </tr>
                    <tr>
                        <td><strong>Counting Sort</strong></td>
                        <td class="time-on">O(n+k)</td>
                        <td class="time-on">O(n+k)</td>
                        <td class="time-on">O(n+k)</td>
                        <td class="time-on">O(k)</td>
                        <td>‚úì</td>
                    </tr>
                    <tr>
                        <td><strong>Radix Sort</strong></td>
                        <td class="time-on">O(nk)</td>
                        <td class="time-on">O(nk)</td>
                        <td class="time-on">O(nk)</td>
                        <td class="time-on">O(n+k)</td>
                        <td>‚úì</td>
                    </tr>
                    <tr>
                        <td><strong>Tim Sort (Python default)</strong></td>
                        <td class="time-on">O(n)</td>
                        <td class="time-onlogn">O(n log n)</td>
                        <td class="time-onlogn">O(n log n)</td>
                        <td class="time-on">O(n)</td>
                        <td>‚úì</td>
                    </tr>
                </tbody>
            </table>
            <p style="color: #6c757d; font-size: 0.9rem; margin-top: 10px;">
                k = range of input values
            </p>

            <h3 style="color: #495057; margin-top: 30px; margin-bottom: 15px;">Search & Graph Algorithms</h3>
            <table class="complexity-table">
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Time Complexity</th>
                        <th>Space Complexity</th>
                        <th>Notes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Binary Search</strong></td>
                        <td class="time-ologn">O(log n)</td>
                        <td class="time-o1">O(1)</td>
                        <td>Requires sorted array</td>
                    </tr>
                    <tr>
                        <td><strong>DFS (Depth First Search)</strong></td>
                        <td class="time-on">O(V+E)</td>
                        <td class="time-on">O(V)</td>
                        <td>Uses stack (recursion)</td>
                    </tr>
                    <tr>
                        <td><strong>BFS (Breadth First Search)</strong></td>
                        <td class="time-on">O(V+E)</td>
                        <td class="time-on">O(V)</td>
                        <td>Uses queue, finds shortest path</td>
                    </tr>
                    <tr>
                        <td><strong>Dijkstra's Algorithm</strong></td>
                        <td class="time-onlogn">O((V+E) log V)</td>
                        <td class="time-on">O(V)</td>
                        <td>With min heap, no negative weights</td>
                    </tr>
                    <tr>
                        <td><strong>Bellman-Ford</strong></td>
                        <td class="time-on">O(VE)</td>
                        <td class="time-on">O(V)</td>
                        <td>Handles negative weights</td>
                    </tr>
                    <tr>
                        <td><strong>Floyd-Warshall</strong></td>
                        <td class="time-on2">O(V¬≥)</td>
                        <td class="time-on2">O(V¬≤)</td>
                        <td>All-pairs shortest path</td>
                    </tr>
                    <tr>
                        <td><strong>Topological Sort</strong></td>
                        <td class="time-on">O(V+E)</td>
                        <td class="time-on">O(V)</td>
                        <td>DAG only</td>
                    </tr>
                    <tr>
                        <td><strong>Kruskal's MST</strong></td>
                        <td class="time-onlogn">O(E log E)</td>
                        <td class="time-on">O(V)</td>
                        <td>Uses Union-Find</td>
                    </tr>
                    <tr>
                        <td><strong>Prim's MST</strong></td>
                        <td class="time-onlogn">O((V+E) log V)</td>
                        <td class="time-on">O(V)</td>
                        <td>With min heap</td>
                    </tr>
                    <tr>
                        <td><strong>A* Search</strong></td>
                        <td class="time-on">O(b^d)</td>
                        <td class="time-on">O(b^d)</td>
                        <td>b=branching factor, d=depth</td>
                    </tr>
                </tbody>
            </table>

            <h3 style="color: #495057; margin-top: 30px; margin-bottom: 15px;">Common Algorithm Patterns</h3>
            <table class="complexity-table">
                <thead>
                    <tr>
                        <th>Pattern/Technique</th>
                        <th>Time Complexity</th>
                        <th>Space Complexity</th>
                        <th>Common Use Cases</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Two Pointers</strong></td>
                        <td class="time-on">O(n)</td>
                        <td class="time-o1">O(1)</td>
                        <td>Sorted arrays, palindromes</td>
                    </tr>
                    <tr>
                        <td><strong>Sliding Window</strong></td>
                        <td class="time-on">O(n)</td>
                        <td class="time-o1">O(1) or O(k)</td>
                        <td>Subarray problems</td>
                    </tr>
                    <tr>
                        <td><strong>Prefix Sum</strong></td>
                        <td class="time-on">O(n) build, O(1) query</td>
                        <td class="time-on">O(n)</td>
                        <td>Range sum queries</td>
                    </tr>
                    <tr>
                        <td><strong>Recursion</strong></td>
                        <td>Varies</td>
                        <td class="time-on">O(depth)</td>
                        <td>Tree/graph traversal</td>
                    </tr>
                    <tr>
                        <td><strong>Dynamic Programming</strong></td>
                        <td class="time-on">O(n) to O(n¬≤)</td>
                        <td class="time-on">O(n) to O(n¬≤)</td>
                        <td>Optimization problems</td>
                    </tr>
                    <tr>
                        <td><strong>Backtracking</strong></td>
                        <td class="time-on2">O(2‚Åø) to O(n!)</td>
                        <td class="time-on">O(n)</td>
                        <td>Permutations, combinations</td>
                    </tr>
                    <tr>
                        <td><strong>Greedy</strong></td>
                        <td class="time-onlogn">O(n log n)</td>
                        <td class="time-o1">O(1)</td>
                        <td>Local optimal choices</td>
                    </tr>
                    <tr>
                        <td><strong>Union-Find (Disjoint Set)</strong></td>
                        <td class="time-o1">O(Œ±(n))* per op</td>
                        <td class="time-on">O(n)</td>
                        <td>Connected components</td>
                    </tr>
                </tbody>
            </table>
            <p style="color: #6c757d; font-size: 0.9rem; margin-top: 10px;">
                * Œ±(n) is inverse Ackermann function, effectively constant
            </p>
        </div>

        <!-- Tradeoffs Section -->
        <div class="tradeoffs-section">
            <h2>‚öñÔ∏è Key Tradeoffs in Data Structures</h2>

            <div class="tradeoff-item">
                <h3>Time vs Space Complexity</h3>
                <ul>
                    <li>Hash tables use O(n) extra space but provide O(1) average access time</li>
                    <li>Arrays are space-efficient but may require O(n) for insertion/deletion in middle</li>
                    <li>Adjacency matrix uses O(V¬≤) space but provides O(1) edge lookup</li>
                    <li>Adjacency list uses O(V+E) space with O(degree) edge lookup</li>
                    <li>Recursion is often cleaner but uses O(h) stack space vs iterative O(1)</li>
                </ul>
            </div>

            <div class="tradeoff-item">
                <h3>Flexibility vs Performance</h3>
                <ul>
                    <li>Python lists (dynamic arrays) resize automatically but may cause reallocation overhead</li>
                    <li>collections.deque provides O(1) append/pop at both ends vs list's O(n) at front</li>
                    <li>Linked lists allow O(1) insertion/deletion but lose cache locality and random access</li>
                    <li>Self-balancing trees maintain O(log n) but require complex rotations</li>
                </ul>
            </div>

            <div class="tradeoff-item">
                <h3>Simplicity vs Functionality</h3>
                <ul>
                    <li>BST is simpler but can degrade to O(n) if unbalanced</li>
                    <li>Python's built-in dict/set are highly optimized - prefer over custom implementations</li>
                    <li>heapq only provides min heap - use negation trick for max heap</li>
                    <li>bisect module provides binary search utilities - no need to reimplement</li>
                </ul>
            </div>

            <div class="tradeoff-item">
                <h3>Memory Access Patterns</h3>
                <ul>
                    <li>Arrays provide excellent cache locality for sequential access</li>
                    <li>Linked structures have poor cache performance due to pointer chasing</li>
                    <li>Hash tables may have scattered memory access affecting cache performance</li>
                    <li>B-trees and B+ trees optimize for disk I/O with larger node sizes</li>
                </ul>
            </div>

            <div class="tradeoff-item">
                <h3>Search Algorithm Tradeoffs</h3>
                <ul>
                    <li>DFS uses O(h) memory where h is height - good for deep searches</li>
                    <li>BFS uses O(w) memory where w is width - finds shortest path in unweighted graphs</li>
                    <li>Iterative deepening combines benefits: O(h) space with BFS-like exploration</li>
                    <li>A* search uses heuristics to improve pathfinding but requires admissible heuristic</li>
                </ul>
            </div>

            <div class="tradeoff-item">
                <h3>Python-Specific Optimizations</h3>
                <ul>
                    <li>Use dict instead of custom hash table - it's implemented in C and highly optimized</li>
                    <li>collections.defaultdict avoids KeyError and simplifies code</li>
                    <li>collections.Counter for counting operations</li>
                    <li>Use enumerate() instead of range(len()) for cleaner iteration</li>
                    <li>List comprehensions are faster than equivalent for loops</li>
                    <li>set operations (union, intersection) are optimized in C</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Tab functionality (if needed later)
        function showTab(tabId, button) {
            const tabs = document.querySelectorAll('.tab-content');
            const buttons = document.querySelectorAll('.tab-button');

            tabs.forEach(tab => {
                tab.classList.remove('active');
            });

            buttons.forEach(btn => {
                btn.classList.remove('active');
            });

            document.getElementById(tabId).classList.add('active');
            button.classList.add('active');
        }
    </script>
</body>

</html>